## A

不难发现结果必然 `<=2`

我int*int过程爆了int（（

LL读入通分即可。

（代码过于丑陋，就不展示了

## B

不难发现，肯定会有 `最大值-最小值`，之后尝试 `+次大值-次小值`

我做的时候，直接放弃思考，1234代表这四个，相对位置暴力枚举了。

或者发现，只要最大值不和次大值在[L,R]或者[L,R]的补集就可以了。

然后发现总是可以做到，所以答案就是 `最大值+次大值-最小值-次小值`

## C

赛时，一开始想会不会是特殊，然后想歪，歪到搜索，写着写着，感觉不对，然后发现贪心。

发现只要有两个相邻0，剩下的1都可以一次操作取一个。

所以，和最终结果有关的就是它是否有相邻的0。

只需要扫一遍即可


赛时题目结束（（

---
——
---
## D

发现关系之和相邻的前后有关，同时$b_i$是单调递增，采用dp

直接可以想到暴力的$O(n^2)$dp。（呜，我没想到（（

### D1

相比D2，$a_i$的大小只有200，发现如果$b_i>=(1<<8)$就必须满足$b_{i-1}>=b_i>>8<<8$（八位以上要相同，因为八位以上此时只与$b_i$有关。

```cpp
for (int i = 0; i < n; i++)
    {
      f[i] = 1;
      for (int j = i >> 8 << 8; j < i; j++)
        if ((a[j] ^ i) < (a[i] ^ j))
          f[i] = max(f[i], f[j] + 1);
      res = max(res, f[i]);
    }
```

ps. `^`的优先级比 `<`高
